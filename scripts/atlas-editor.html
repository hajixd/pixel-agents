<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Tileset Atlas Editor</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; display: flex; height: 100vh; overflow: hidden; }

  /* Left panel: tileset canvas */
  #left { flex: 1; display: flex; flex-direction: column; min-width: 0; }
  #toolbar { padding: 8px 12px; background: #16213e; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #333; }
  #toolbar label { font-size: 12px; color: #aaa; }
  #toolbar select, #toolbar input, #toolbar button {
    font-size: 12px; padding: 3px 8px; border-radius: 3px; border: 1px solid #555;
    background: #2a2a4a; color: #e0e0e0; cursor: pointer;
  }
  #toolbar button { background: #0f3460; border-color: #1a5276; }
  #toolbar button:hover { background: #1a5276; }
  #toolbar button.danger { background: #6b2020; border-color: #8b3030; }
  #toolbar button.danger:hover { background: #8b3030; }
  #toolbar .sep { width: 1px; height: 20px; background: #444; }

  #canvas-wrap { flex: 1; overflow: auto; position: relative; background: #111; }
  #canvas-wrap canvas { display: block; image-rendering: pixelated; cursor: crosshair; }

  #status { padding: 4px 12px; background: #16213e; font-size: 11px; color: #888; border-top: 1px solid #333; }

  /* Right panel: entry list */
  #right { width: 380px; display: flex; flex-direction: column; border-left: 1px solid #333; background: #16213e; }
  #right h3 { padding: 8px 12px; font-size: 13px; border-bottom: 1px solid #333; background: #0f3460; }
  #entry-list { flex: 1; overflow-y: auto; padding: 4px; }
  .entry {
    padding: 6px 8px; margin: 2px 0; border-radius: 4px; font-size: 11px;
    background: #1a1a3e; border: 1px solid #333; cursor: pointer; display: flex; gap: 6px; align-items: center;
  }
  .entry:hover { border-color: #555; }
  .entry.selected { border-color: #3498db; background: #1a2a4e; }
  .entry canvas { flex-shrink: 0; image-rendering: pixelated; background: #111; border-radius: 2px; }
  .entry-info { flex: 1; min-width: 0; }
  .entry-name { font-weight: 600; color: #eee; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .entry-meta { color: #888; font-size: 10px; margin-top: 1px; }
  .cat-badge {
    display: inline-block; padding: 1px 5px; border-radius: 2px; font-size: 9px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.5px;
  }
  .cat-desks { background: #1a5276; color: #7ec8e3; }
  .cat-chairs { background: #6b3a6b; color: #d4a5d4; }
  .cat-storage { background: #4a6b3a; color: #a5d4a5; }
  .cat-electronics { background: #6b6b3a; color: #d4d4a5; }
  .cat-decor { background: #6b4a3a; color: #d4b5a5; }
  .cat-misc { background: #3a4a6b; color: #a5b5d4; }

  #right-actions { padding: 8px 12px; border-top: 1px solid #333; display: flex; gap: 6px; flex-wrap: wrap; }
  #right-actions button { font-size: 12px; padding: 4px 12px; border-radius: 3px; border: 1px solid #555; background: #0f3460; color: #e0e0e0; cursor: pointer; }
  #right-actions button:hover { background: #1a5276; }
  #right-actions button.primary { background: #27ae60; border-color: #2ecc71; }
  #right-actions button.primary:hover { background: #2ecc71; }

  /* Edit form (inline in right panel) */
  #edit-form { padding: 8px 12px; border-top: 1px solid #333; background: #1a1a3e; }
  #edit-form .row { display: flex; gap: 6px; margin-bottom: 4px; align-items: center; }
  #edit-form label { font-size: 11px; color: #aaa; width: 65px; text-align: right; flex-shrink: 0; }
  #edit-form input, #edit-form select {
    font-size: 11px; padding: 2px 6px; border-radius: 2px; border: 1px solid #555;
    background: #2a2a4a; color: #e0e0e0; flex: 1;
  }
  #edit-form input[type="checkbox"] { flex: 0; width: 14px; height: 14px; }

  /* Modal for JSON export */
  #modal-overlay {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 100;
    justify-content: center; align-items: center;
  }
  #modal-overlay.show { display: flex; }
  #modal {
    background: #1a1a3e; border: 1px solid #555; border-radius: 8px; padding: 16px;
    width: 700px; max-height: 80vh; display: flex; flex-direction: column; gap: 8px;
  }
  #modal h3 { font-size: 14px; }
  #modal textarea {
    flex: 1; min-height: 400px; font-family: 'Cascadia Code', monospace; font-size: 11px;
    background: #111; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; padding: 8px; resize: none;
  }
  #modal .actions { display: flex; gap: 8px; justify-content: flex-end; }
  #modal button {
    font-size: 12px; padding: 4px 16px; border-radius: 3px; border: 1px solid #555;
    background: #0f3460; color: #e0e0e0; cursor: pointer;
  }
  #modal button:hover { background: #1a5276; }
  #modal button.primary { background: #27ae60; border-color: #2ecc71; }
</style>
</head>
<body>

<!-- Left: Canvas area -->
<div id="left">
  <div id="toolbar">
    <label>Zoom:</label>
    <select id="zoom-select">
      <option value="2">2x</option>
      <option value="3" selected>3x</option>
      <option value="4">4x</option>
      <option value="5">5x</option>
      <option value="6">6x</option>
    </select>
    <div class="sep"></div>
    <label>Category:</label>
    <select id="cat-select">
      <option value="desks">Desks</option>
      <option value="chairs">Chairs</option>
      <option value="storage">Storage</option>
      <option value="electronics">Electronics</option>
      <option value="decor" selected>Decor</option>
      <option value="misc">Misc</option>
    </select>
    <label><input type="checkbox" id="is-desk-check"> isDesk</label>
    <div class="sep"></div>
    <label>Grid snap:</label>
    <select id="snap-select">
      <option value="16" selected>16px (1 tile)</option>
      <option value="8">8px (half tile)</option>
      <option value="1">1px (free)</option>
    </select>
    <div class="sep"></div>
    <label>Grid offset X:</label>
    <input id="offset-x" type="number" value="0" min="-16" max="16" style="width:50px">
    <label>Y:</label>
    <input id="offset-y" type="number" value="0" min="-16" max="16" style="width:50px">
    <div class="sep"></div>
    <button id="btn-load">Load Image</button>
    <button id="btn-import">Import JSON</button>
  </div>
  <div id="canvas-wrap">
    <canvas id="tileset-canvas"></canvas>
  </div>
  <div id="status">Load a tileset image to begin. Draw rectangles to select sprites.</div>
</div>

<!-- Right: Entry list -->
<div id="right">
  <h3>Entries (<span id="entry-count">0</span>)</h3>
  <div id="entry-list"></div>
  <div id="edit-form" style="display:none">
    <div class="row"><label>Name:</label><input id="ef-name" type="text" placeholder="TABLE_WOOD_SM"></div>
    <div class="row"><label>Label:</label><input id="ef-label" type="text" placeholder="Sm Wood Table"></div>
    <div class="row"><label>Category:</label>
      <select id="ef-category">
        <option value="desks">Desks</option>
        <option value="chairs">Chairs</option>
        <option value="storage">Storage</option>
        <option value="electronics">Electronics</option>
        <option value="decor">Decor</option>
        <option value="misc">Misc</option>
      </select>
    </div>
    <div class="row"><label>Footprint:</label><input id="ef-fpw" type="number" min="1" max="10" style="width:50px;flex:0"> x <input id="ef-fph" type="number" min="1" max="10" style="width:50px;flex:0"></div>
    <div class="row"><label>isDesk:</label><input id="ef-isdesk" type="checkbox"></div>
    <div class="row"><label></label><button id="ef-apply" style="font-size:11px;padding:2px 10px;background:#27ae60;border:1px solid #2ecc71;color:#fff;border-radius:3px;cursor:pointer">Apply</button>
    <button id="ef-delete" style="font-size:11px;padding:2px 10px;background:#6b2020;border:1px solid #8b3030;color:#fff;border-radius:3px;cursor:pointer">Delete</button></div>
  </div>
  <div id="right-actions">
    <button class="primary" id="btn-export">Export JSON</button>
    <button id="btn-clear" class="danger" style="background:#6b2020;border-color:#8b3030">Clear All</button>
  </div>
</div>

<!-- Modal -->
<div id="modal-overlay">
  <div id="modal">
    <h3 id="modal-title">Export</h3>
    <textarea id="modal-text" readonly></textarea>
    <div class="actions">
      <button onclick="copyModalText()">Copy to Clipboard</button>
      <button onclick="closeModal()">Close</button>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept="image/png" style="display:none">

<script>
// ── State ──────────────────────────────────────────────────
let img = null;
let zoom = 3;
let snap = 16;
let gridOffsetX = 0;
let gridOffsetY = 0;
let entries = [];
let selectedIdx = -1;
let drawing = false;
let drawStart = null;
let drawEnd = null;

const canvas = document.getElementById('tileset-canvas');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('canvas-wrap');
const status = document.getElementById('status');
const entryList = document.getElementById('entry-list');
const entryCount = document.getElementById('entry-count');
const editForm = document.getElementById('edit-form');

// ── Image loading ──────────────────────────────────────────
document.getElementById('btn-load').onclick = () => document.getElementById('file-input').click();
document.getElementById('file-input').onchange = (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const i = new Image();
    i.onload = () => { img = i; render(); status.textContent = `Loaded: ${i.width}x${i.height}px (${i.width/16}x${i.height/16} tiles)`; };
    i.src = ev.target.result;
  };
  reader.readAsDataURL(file);
};

// ── Zoom / snap / grid offset ──────────────────────────────
document.getElementById('zoom-select').onchange = (e) => { zoom = +e.target.value; render(); };
document.getElementById('snap-select').onchange = (e) => { snap = +e.target.value; };
document.getElementById('offset-x').onchange = (e) => { gridOffsetX = +e.target.value; render(); };
document.getElementById('offset-y').onchange = (e) => { gridOffsetY = +e.target.value; render(); };
document.getElementById('offset-x').oninput = (e) => { gridOffsetX = +e.target.value; render(); };
document.getElementById('offset-y').oninput = (e) => { gridOffsetY = +e.target.value; render(); };

// ── Canvas rendering ───────────────────────────────────────
function render() {
  if (!img) return;
  canvas.width = img.width * zoom;
  canvas.height = img.height * zoom;
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw tileset
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  // Draw grid (with offset)
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  for (let x = gridOffsetX; x <= img.width; x += 16) {
    if (x < 0) continue;
    ctx.beginPath(); ctx.moveTo(x * zoom + 0.5, 0); ctx.lineTo(x * zoom + 0.5, canvas.height); ctx.stroke();
  }
  for (let y = gridOffsetY; y <= img.height; y += 16) {
    if (y < 0) continue;
    ctx.beginPath(); ctx.moveTo(0, y * zoom + 0.5); ctx.lineTo(canvas.width, y * zoom + 0.5); ctx.stroke();
  }

  // Draw existing entries
  entries.forEach((entry, i) => {
    const x = entry.col * 16 * zoom;
    const y = entry.row * 16 * zoom;
    const w = entry.w * 16 * zoom;
    const h = entry.h * 16 * zoom;
    const isSelected = i === selectedIdx;

    ctx.strokeStyle = isSelected ? '#3498db' : '#2ecc71';
    ctx.lineWidth = isSelected ? 3 : 2;
    ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

    // Label
    ctx.font = `bold ${Math.max(10, zoom * 3)}px monospace`;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    const textW = ctx.measureText(entry.name).width;
    ctx.fillRect(x + 2, y + 2, textW + 4, zoom * 4 + 2);
    ctx.fillStyle = isSelected ? '#3498db' : '#2ecc71';
    ctx.fillText(entry.name, x + 4, y + zoom * 3 + 2);
  });

  // Draw current selection rectangle
  if (drawing && drawStart && drawEnd) {
    const x1 = Math.min(drawStart.x, drawEnd.x) * zoom;
    const y1 = Math.min(drawStart.y, drawEnd.y) * zoom;
    const x2 = Math.max(drawStart.x, drawEnd.x) * zoom;
    const y2 = Math.max(drawStart.y, drawEnd.y) * zoom;
    ctx.strokeStyle = '#e74c3c';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    ctx.setLineDash([]);

    // Show pixel dimensions
    const pw = Math.abs(drawEnd.x - drawStart.x);
    const ph = Math.abs(drawEnd.y - drawStart.y);
    ctx.font = `bold ${Math.max(10, zoom * 3)}px monospace`;
    ctx.fillStyle = '#e74c3c';
    ctx.fillText(`${pw}x${ph}px (${pw/16}x${ph/16} tiles)`, x1 + 4, y1 - 4);
  }
}

// ── Canvas mouse interaction ───────────────────────────────
function snapCoord(px, offset) {
  // Shift into offset-relative space, snap, shift back
  return Math.round((px - offset) / snap) * snap + offset;
}

function canvasToImg(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / zoom;
  const y = (e.clientY - rect.top) / zoom;
  return { x: snapCoord(x, gridOffsetX), y: snapCoord(y, gridOffsetY) };
}

canvas.onmousedown = (e) => {
  if (e.button !== 0) return;

  // Check if clicking an existing entry
  const pos = canvasToImg(e);
  const rawX = (e.clientX - canvas.getBoundingClientRect().left) / zoom;
  const rawY = (e.clientY - canvas.getBoundingClientRect().top) / zoom;

  // Check click on existing entries (reverse order for top-most)
  for (let i = entries.length - 1; i >= 0; i--) {
    const ent = entries[i];
    const ex = ent.col * 16, ey = ent.row * 16;
    const ew = ent.w * 16, eh = ent.h * 16;
    if (rawX >= ex && rawX < ex + ew && rawY >= ey && rawY < ey + eh) {
      // If already selected, start drawing a new one instead
      if (i === selectedIdx) {
        selectedIdx = -1;
      } else {
        selectedIdx = i;
        renderEntryList();
        showEditForm(i);
        render();
        return;
      }
    }
  }

  drawing = true;
  drawStart = pos;
  drawEnd = pos;
  selectedIdx = -1;
  renderEntryList();
  editForm.style.display = 'none';
  render();
};

canvas.onmousemove = (e) => {
  const pos = canvasToImg(e);
  if (drawing) {
    drawEnd = pos;
    render();
  }
  // Update status
  const rawX = (e.clientX - canvas.getBoundingClientRect().left) / zoom;
  const rawY = (e.clientY - canvas.getBoundingClientRect().top) / zoom;
  const tileC = Math.floor((rawX - gridOffsetX) / 16);
  const tileR = Math.floor((rawY - gridOffsetY) / 16);
  const offsetStr = (gridOffsetX || gridOffsetY) ? ` | Grid offset: (${gridOffsetX}, ${gridOffsetY})` : '';
  status.textContent = `Pixel: (${Math.floor(rawX)}, ${Math.floor(rawY)}) | Tile: (${tileC}, ${tileR})${offsetStr}`;
  if (drawing) {
    const pw = Math.abs(drawEnd.x - drawStart.x);
    const ph = Math.abs(drawEnd.y - drawStart.y);
    status.textContent += ` | Selection: ${pw}x${ph}px (${pw/16}x${ph/16} tiles)`;
  }
};

canvas.onmouseup = (e) => {
  if (!drawing) return;
  drawing = false;
  drawEnd = canvasToImg(e);

  const x1 = Math.min(drawStart.x, drawEnd.x);
  const y1 = Math.min(drawStart.y, drawEnd.y);
  const x2 = Math.max(drawStart.x, drawEnd.x);
  const y2 = Math.max(drawStart.y, drawEnd.y);
  const pw = x2 - x1;
  const ph = y2 - y1;

  if (pw < 4 || ph < 4) { drawStart = drawEnd = null; render(); return; }

  const col = x1 / 16;
  const row = y1 / 16;
  const w = pw / 16;
  const h = ph / 16;

  const cat = document.getElementById('cat-select').value;
  const isDesk = document.getElementById('is-desk-check').checked;

  // Auto-generate a name
  const count = entries.filter(e => e.category === cat).length + 1;
  const prefix = cat.toUpperCase().slice(0, 4);
  const name = `${prefix}_${count}`;

  entries.push({
    name,
    label: name.replace(/_/g, ' '),
    col: Math.round(col * 100) / 100,
    row: Math.round(row * 100) / 100,
    w: Math.round(w * 100) / 100,
    h: Math.round(h * 100) / 100,
    footprintW: Math.max(1, Math.round(w)),
    footprintH: Math.max(1, Math.round(h)),
    isDesk,
    category: cat,
  });

  selectedIdx = entries.length - 1;
  drawStart = drawEnd = null;
  renderEntryList();
  showEditForm(selectedIdx);
  render();
};

// ── Entry list rendering ───────────────────────────────────
function renderEntryList() {
  entryCount.textContent = entries.length;
  entryList.innerHTML = '';
  entries.forEach((entry, i) => {
    const div = document.createElement('div');
    div.className = 'entry' + (i === selectedIdx ? ' selected' : '');
    div.onclick = () => { selectedIdx = i; renderEntryList(); showEditForm(i); render(); };

    // Thumbnail canvas
    const thumb = document.createElement('canvas');
    const sz = 32;
    thumb.width = sz; thumb.height = sz;
    thumb.style.width = sz + 'px'; thumb.style.height = sz + 'px';
    if (img) {
      const tctx = thumb.getContext('2d');
      tctx.imageSmoothingEnabled = false;
      const srcX = entry.col * 16, srcY = entry.row * 16;
      const srcW = entry.w * 16, srcH = entry.h * 16;
      const scale = Math.min(sz / srcW, sz / srcH);
      const dw = srcW * scale, dh = srcH * scale;
      tctx.drawImage(img, srcX, srcY, srcW, srcH, (sz - dw) / 2, (sz - dh) / 2, dw, dh);
    }
    div.appendChild(thumb);

    const info = document.createElement('div');
    info.className = 'entry-info';
    info.innerHTML = `
      <div class="entry-name">${entry.name}</div>
      <div class="entry-meta">
        <span class="cat-badge cat-${entry.category}">${entry.category}</span>
        ${entry.w}x${entry.h} tiles | fp: ${entry.footprintW}x${entry.footprintH}
        ${entry.isDesk ? ' | <b style="color:#7ec8e3">DESK</b>' : ''}
      </div>
    `;
    div.appendChild(info);
    entryList.appendChild(div);
  });

  // Scroll selected into view
  if (selectedIdx >= 0) {
    const el = entryList.children[selectedIdx];
    if (el) el.scrollIntoView({ block: 'nearest' });
  }
}

// ── Edit form ──────────────────────────────────────────────
function showEditForm(idx) {
  if (idx < 0 || idx >= entries.length) { editForm.style.display = 'none'; return; }
  editForm.style.display = 'block';
  const e = entries[idx];
  document.getElementById('ef-name').value = e.name;
  document.getElementById('ef-label').value = e.label;
  document.getElementById('ef-category').value = e.category;
  document.getElementById('ef-fpw').value = e.footprintW;
  document.getElementById('ef-fph').value = e.footprintH;
  document.getElementById('ef-isdesk').checked = e.isDesk;
}

document.getElementById('ef-apply').onclick = () => {
  if (selectedIdx < 0) return;
  const e = entries[selectedIdx];
  e.name = document.getElementById('ef-name').value.trim() || e.name;
  e.label = document.getElementById('ef-label').value.trim() || e.label;
  e.category = document.getElementById('ef-category').value;
  e.footprintW = +document.getElementById('ef-fpw').value || e.footprintW;
  e.footprintH = +document.getElementById('ef-fph').value || e.footprintH;
  e.isDesk = document.getElementById('ef-isdesk').checked;
  renderEntryList();
  render();
};

document.getElementById('ef-delete').onclick = () => {
  if (selectedIdx < 0) return;
  entries.splice(selectedIdx, 1);
  selectedIdx = -1;
  editForm.style.display = 'none';
  renderEntryList();
  render();
};

// ── Export / Import ────────────────────────────────────────
document.getElementById('btn-export').onclick = () => {
  const json = JSON.stringify(entries, null, 2);
  document.getElementById('modal-title').textContent = `Export JSON (${entries.length} entries)`;
  document.getElementById('modal-text').value = json;
  document.getElementById('modal-overlay').classList.add('show');
};

document.getElementById('btn-import').onclick = () => {
  document.getElementById('modal-title').textContent = 'Import JSON';
  document.getElementById('modal-text').value = '';
  document.getElementById('modal-text').readOnly = false;
  document.getElementById('modal-overlay').classList.add('show');

  // Temporarily swap copy button for import
  const actions = document.querySelector('#modal .actions');
  const oldHTML = actions.innerHTML;
  actions.innerHTML = '<button class="primary" id="do-import">Import</button> <button onclick="closeModal()">Cancel</button>';
  document.getElementById('do-import').onclick = () => {
    try {
      const data = JSON.parse(document.getElementById('modal-text').value);
      if (Array.isArray(data)) {
        entries = data;
        selectedIdx = -1;
        renderEntryList();
        render();
        closeModal();
      } else {
        alert('Expected a JSON array');
      }
    } catch (err) { alert('Invalid JSON: ' + err.message); }
    actions.innerHTML = oldHTML;
  };
};

document.getElementById('btn-clear').onclick = () => {
  if (!confirm('Clear all entries?')) return;
  entries = [];
  selectedIdx = -1;
  editForm.style.display = 'none';
  renderEntryList();
  render();
};

function closeModal() {
  document.getElementById('modal-overlay').classList.remove('show');
  document.getElementById('modal-text').readOnly = true;
}

function copyModalText() {
  const ta = document.getElementById('modal-text');
  ta.select();
  navigator.clipboard.writeText(ta.value).then(() => {
    status.textContent = 'Copied to clipboard!';
  });
}

document.getElementById('modal-overlay').onclick = (e) => {
  if (e.target === document.getElementById('modal-overlay')) closeModal();
};

// ── Keyboard shortcuts ─────────────────────────────────────
document.onkeydown = (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

  if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedIdx >= 0) {
      entries.splice(selectedIdx, 1);
      selectedIdx = -1;
      editForm.style.display = 'none';
      renderEntryList();
      render();
    }
  }
  if (e.key === 'Escape') {
    selectedIdx = -1;
    drawing = false;
    drawStart = drawEnd = null;
    editForm.style.display = 'none';
    renderEntryList();
    render();
    closeModal();
  }
};

// ── Persist to localStorage ────────────────────────────────
function save() {
  try { localStorage.setItem('atlas-entries', JSON.stringify(entries)); } catch {}
}
function load() {
  try {
    const d = localStorage.getItem('atlas-entries');
    if (d) entries = JSON.parse(d);
  } catch {}
}

// Auto-save every 2s
setInterval(save, 2000);

// Load on startup
load();
renderEntryList();

// If there's a drag-and-drop file
document.body.ondragover = (e) => e.preventDefault();
document.body.ondrop = (e) => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (!file || !file.type.startsWith('image/')) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const i = new Image();
    i.onload = () => { img = i; render(); status.textContent = `Loaded: ${i.width}x${i.height}px`; };
    i.src = ev.target.result;
  };
  reader.readAsDataURL(file);
};
</script>
</body>
</html>
